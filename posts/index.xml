<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Will</title><link>http://willerhe.github.io/posts/</link><description>Recent content in Posts on Will</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 02 Jun 2021 13:31:54 +0800</lastBuildDate><atom:link href="http://willerhe.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Mysql的Json相关操作</title><link>http://willerhe.github.io/posts/note/mysql/</link><pubDate>Wed, 02 Jun 2021 13:31:54 +0800</pubDate><guid>http://willerhe.github.io/posts/note/mysql/</guid><description>Mysql Json相关操作 官方文档
1. 合并两个json数组(不去重)
- `select JSON_MERGE_PRESERVE('[&amp;quot;1&amp;quot;]','[&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;]');` 结果：`[&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;]` 2. 合并两个json数组(去重)
- `select JSON_MERGE_PATCH('[&amp;quot;1&amp;quot;]','[&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;]');` 结果：`[&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;]` 3. 查询json对象字段
sku字段内容：`{name:&amp;quot;校服&amp;quot;}` - `SELECT sku-&amp;gt;&amp;quot;$.name&amp;quot; FROM trade_store_sku` 结果：`&amp;quot;校服&amp;quot;` - `SELECT sku-&amp;gt;&amp;gt;&amp;quot;$.name&amp;quot; FROM trade_store_sku` 结果：`校服` 4. 赋值
- `SELECT JSON_SET('{&amp;quot;name&amp;quot;:&amp;quot;校服&amp;quot;}', &amp;quot;$.name&amp;quot;, &amp;quot;秋装&amp;quot;)` 结果：`{&amp;quot;name&amp;quot;: &amp;quot;秋装&amp;quot;}` - `SELECT JSON_SET('[&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;]', &amp;quot;$[1]&amp;quot;, &amp;quot;秋装&amp;quot;)` 结果：`[&amp;quot;1&amp;quot;, &amp;quot;秋装&amp;quot;, &amp;quot;3&amp;quot;]` 5. 删除
- `SELECT JSON_REMOVE('{&amp;quot;name&amp;quot;:&amp;quot;校服&amp;quot;}', &amp;quot;$.name&amp;quot;)` 结果：`{}` - `SELECT JSON_REMOVE('[&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;]', &amp;quot;$[1]&amp;quot;)` 结果：`[&amp;quot;1&amp;quot;, &amp;quot;3&amp;quot;]`</description></item><item><title>十分钟使用Github Actions自动发布Hugo网站</title><link>http://willerhe.github.io/posts/tutorial/use-github-actions/</link><pubDate>Sat, 29 May 2021 13:31:54 +0800</pubDate><guid>http://willerhe.github.io/posts/tutorial/use-github-actions/</guid><description>介绍 Github Actions是GitHub 于 2018 年 10 月推出的一个 CI\CD 服务。CI\CD 其实说的是三件事情：「持续集成（Continuous Integration）」、「持续交付（Continuous Delivery）」、「持续部署（Continuous Deployment）」。 有了 GitHub Action 以后， GitHub 除了能够存储代码，能做的事情就更多了，比如我在 master 分支上提交了一段代码， GitHub Action 可以自动的帮我部署到我自己的服务器上去，或者它还可以帮我把代码打成镜像，将镜像自动提交到镜像仓库里。 虽然这些事情自己手动也能做，但是懒惰是程序员的第一生产力嘛。
环境要求 安装git 拥有一个github账号 了解Github Pages托管静态网站方式 Check&amp;gt;&amp;gt;&amp;gt; TODO：自动同步到Gitee镜像 步骤 了解github actions的工作流程、了解docker镜像基本使用方式。 找到需要自动构建的Hugo静态网站，并确保在本地能够构建成功。 开始使用github actions 服务，github actions会寻找项目根目录下.github/workflows/*下面所有的文件作为工作流描述文件，了解详情&amp;gt;&amp;gt;&amp;gt;。 这里我们不需要自己编写，直接使用第三方镜像，在github的应用市场 中查找适合自己Hugo项目的actions镜像，这里用的是hugo-setup。 把示例项目中.github/workflows/下面的配置文件拷贝到自己的项目中，如果同样使用的是hugo-setup，注意 publish_dir: ./public配置在v3.8.0版本是不起作用的，直接默认就好，不用改。 如果报项目仓库的访问权限错误，去给自己的项目加上访问秘钥，&amp;gt;&amp;gt;&amp;gt;。 修改代码推送到main分支，在github actions栏目中能够看到构建过程。构建成功后，修改git pages设置，把网站指向镜像自动部署的分支，要保证github pages能够找到index.html文件。 &amp;mdash;&amp;mdash; 待完善</description></item><item><title>十分钟使用Github Pages和Hugo搭建个人网站</title><link>http://willerhe.github.io/posts/tutorial/use-github-pages/</link><pubDate>Sat, 29 May 2021 13:31:54 +0800</pubDate><guid>http://willerhe.github.io/posts/tutorial/use-github-pages/</guid><description>介绍 Github Pages是Github官方的静态站点托管系统，能够依赖Git的代码管理能力和Github的仓库轻松维护个人网站。
Hugo是Go编写的静态网站生成器，速度快，易用，可配置。 使用Github Pages + Hugo构建个人网站的优点：
无须额外服务器，无须额外服务器，专注创作 支持Markdown 支持查看文件的历史改动 Hugo拥有海量皮肤，能够自定义 环境要求 安装git 安装golang、hugo 拥有一个github账号 步骤 为站点创建仓库，仓库名称必须为&amp;lt;user&amp;gt;.github.io或者&amp;lt;organization&amp;gt;.github.io，必须为Public仓库，必须有README.md文件，必须有index.html作为网站入口。More&amp;gt;&amp;gt;&amp;gt; 访问网站https://&amp;lt;user&amp;gt;.github.io或者&amp;lt;https://&amp;lt;organization&amp;gt;.github.io。看到index.html中的内容说明成功。 了解静态网站生成器，github官方是Jekyll，因为之前用过Hugo，体验非常好，所以改用Hugo。还有更多类似的 类似工具， 但是最终目的是相同的，要把我们的文档内容转为静态网页文件，关于Hugo的安装和使用查看见详情。 一切顺利的话，一个好看的网站就诞生了。 &amp;mdash;&amp;mdash; 待完善</description></item><item><title/><link>http://willerhe.github.io/posts/resume/untitled/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://willerhe.github.io/posts/resume/untitled/</guid><description>Spring事务的默认隔离级别? 默认隔离级别：REPEATED_READ
READ_UNCOMMITED 读未提交 高并发场景下，其他线程可以读到未提交的事务的数据 ，可能出现脏读、幻读或不可重复读 READ_COMMITED 读已提交 只能读到已提交的数据 REPEATED_READ 重复读 能读到当前事务中的未提交的数据和其他事务已经提交的数据 SERIALIZABLE 串行化 事务挨个执行，不存在脏读、幻读、不可重复读问题，但是影响性能 常见的设计模式？ 单例模式 装饰器模式 一个统一的抽象父类，不同的子类有自己不同的装饰属性和装饰方法 工厂模式 流程一致，但每个子类的单独流程处理不同 建造者模式 SQL build就是非常常见的一种建造者模式 观察者模式 即发布订阅模式 常用的软件工程图。时序图、状态图、ER图、流程图 Mysql常用的方法 concat、ifnull、upper、substr、trim、rpad、lpad、replace、round、now、currenttime、UNIX_TIMESTAMP、FROM_UNIXTIMEMysql分页的实现 limit offset 传统实现 通过有序id去实现 覆盖索引，利用索引优势select * from (select id from job limit 1000000,100) a left join job b on a.id = b.id; 如何处理超卖订单？ 避免超卖订单的产生：分布式锁（redison）底层是用Lua脚本实现的redis原子执行，乐观锁、自旋锁。
还有可能出现的问题：redis主从切换导致锁丢失
mq 的典型应用场景，项目中什么地方用到过，怎么实现的？ 目的：削峰、解耦
高可用：rabbitmq的镜像集群的部署模式
&amp;hellip;
什么场景下会使用多线程 一个业务有很多处理流程并且处理流程之间不会相互影响 定时任务、批处理任务 需要知道一个任务的执行情况，比如redission中自动续期功能的实现就是一个新的线程不断查看锁的引用状态 Redis的几种基本数据类型 String 键值对Hash 列表list 集合set 有序集合zset Mybatis怎么用WhereIn 不能够直接写会有sql注入问题，用Mybatis的foreach方法对数组进行处理。</description></item></channel></rss>